import heapq

# -----------------------------
# A* Algorithm Implementation
# -----------------------------

def heuristic(a, b):
    """Heuristic function (Manhattan distance)."""
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def astar(grid, start, goal):
    """Find the shortest path using A* algorithm."""
    rows, cols = len(grid), len(grid[0])
    open_set = []
    heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start, [start]))
    visited = set()
    
    while open_set:
        f, g, current, path = heapq.heappop(open_set)
        
        if current == goal:
            return path
        
        if current in visited:
            continue
        visited.add(current)
        
        x, y = current
        # Explore 4 directions (up, down, left, right)
        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
            nx, ny = x + dx, y + dy
            
            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0:
                neighbor = (nx, ny)
                if neighbor not in visited:
                    new_g = g + 1
                    f_score = new_g + heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f_score, new_g, neighbor, path + [neighbor]))
    
    return None  # No path found

# -----------------------------
# Example Grid (0 = free, 1 = obstacle)
# -----------------------------
grid = [
    [0, 0, 0, 0, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [0, 1, 1, 0, 0],
    [0, 0, 0, 0, 0]
]

start = (0, 0)
goal = (4, 4)

path = astar(grid, start, goal)

# -----------------------------
# Display Results
# -----------------------------
print("Optimal Path:", path)

# Optional: visualize
if path:
    for (x, y) in path:
        grid[x][y] = "*"
    for row in grid:
        print(row)
else:
    print("No path found.")
